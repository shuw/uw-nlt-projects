package edu.nlt.ling570.project2;

import java.io.File;
import java.util.Collection;

import edu.nlt.ling570.project2.data.LinguisticCluster;
import edu.nlt.ling570.project2.processor.DocumentVectorProcessor;
import edu.nlt.ling570.project2.processor.PlainWordProcessor;
import edu.nlt.shallow.data.Vocabulary;
import edu.nlt.shallow.data.vector.DocumentVector;
import edu.nlt.util.InputUtil;

public class Classify {

	/**
	 * Classifies standard input as Linguistic / Non-linguistic
	 * 
	 * @param args
	 * 
	 * 
	 *            args[0] - Vocabulary file
	 * 
	 *            args[1] - Cluster centroids file (generated by PrintClusters
	 *            program)
	 * 
	 * 
	 */
	public static void main(String[] args) {

		Vocabulary vocabulary = Util.getVocabulary(new File(args[0]), -1);
		Collection<LinguisticCluster> clusters = Util.getClusters(new File(args[1]), vocabulary);

		// Create document vector for input
		//
		DocumentVector document;
		{
			DocumentVectorProcessor processor = new DocumentVectorProcessor(vocabulary,
					"Standard input");
			InputUtil.process(System.in, new PlainWordProcessor(processor));
			document = processor.getDocumentVector();
		}

		System.out.println(isPositive(clusters, document) ? "Linguistic" : "Non-linguistic");
	}

	public static boolean isPositive(Collection<LinguisticCluster> clusters, DocumentVector document) {
		double maxSimiliraty = Double.MIN_VALUE;
		boolean isLinguistic = false;

		for (LinguisticCluster cluster : clusters) {

			double similarity = cluster.getCosineSimilarity(document);
			if (similarity > maxSimiliraty) {
				maxSimiliraty = similarity;
				isLinguistic = cluster.isPositive();

			}

		}

		return isLinguistic;
	}

	public static double getPositiveSimliarityScore(Collection<LinguisticCluster> clusters,
			DocumentVector document) {
		double maxSimiliraty = Double.MIN_VALUE;

		for (LinguisticCluster cluster : clusters) {
			if (cluster.isPositive()) {
				double similarity = cluster.getCosineSimilarity(document);
				if (similarity > maxSimiliraty) {
					maxSimiliraty = similarity;
				}
			}
		}

		return maxSimiliraty;
	}

}
