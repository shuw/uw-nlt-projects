package edu.nlt.ling570.hw5;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;

import edu.nlt.ling570.project2.Classify;
import edu.nlt.ling570.project2.Util;
import edu.nlt.ling570.project2.data.ClassifierGoldStandard;
import edu.nlt.ling570.project2.data.LinguisticCluster;
import edu.nlt.shallow.classifier.BinaryFileClassifier;
import edu.nlt.shallow.classifier.NotClassifiedException;
import edu.nlt.shallow.data.Vocabulary;
import edu.nlt.shallow.data.vector.DocumentVector;
import edu.nlt.util.FileProcessor;
import edu.nlt.util.FileUtil;
import edu.nlt.util.Formatters;
import edu.nlt.util.Globals;
import edu.nlt.util.MathUtil;

public class PrintHw5 {
	/**
	 * Print results
	 * 
	 * @param args
	 * 
	 * 
	 *            args[0] - Vocabulary file
	 * 
	 *            args[1] - Cluster centroids file (generated by PrintClusters
	 *            program)
	 * 
	 *            args[2] - Path to test data
	 * 
	 *            args[3] - Output file - sorted list of e-mail documents
	 * 
	 *            args[4] - Output file - sorted list of spam documents
	 * 
	 *            args[5] - Output file - precision and recall numbers
	 */
	public static void main(String[] args) {

		final Vocabulary vocabulary = Util.getVocabulary(new File(args[0]), -1);
		final Collection<LinguisticCluster> clusters = Util.getClusters(new File(args[1]),
				vocabulary);

		final TrainingDataClassifier goldStandard = new TrainingDataClassifier();

		// Process files
		//
		TestProcessor processor = new TestProcessor(vocabulary, clusters, goldStandard);
		{
			String path = args[2];

			for (File file : FileUtil.getFiles(path + "/" + TrainingDataClassifier.EmailFolderName,
					false)) {
				processor.processFile(file);
			}

			for (File file : FileUtil.getFiles(path + "/" + TrainingDataClassifier.SpamFolderName,
					false)) {
				processor.processFile(file);
			}
		}

		// Print results
		//
		PrintStream emailStream;
		PrintStream spamStream;
		PrintStream scoreStream;
		try {
			emailStream = new PrintStream(new FileOutputStream(new File(args[3])));
			spamStream = new PrintStream(new FileOutputStream(new File(args[4])));
			scoreStream = new PrintStream(new FileOutputStream(new File(args[5])));

			for (FileScore file : getSorted(processor.getPositiveFiles())) {
				emailStream.println(file.getFile().getName() + "\t"
						+ Formatters.FractionFormatter.format(file.getScore()));
			}

			for (FileScore file : getSorted(processor.getNegativeFiles())) {
				spamStream.println(file.getFile().getName() + "\t"
						+ Formatters.FractionFormatter.format(file.getScore()));
			}

			processor.printPrescisionRecall(scoreStream);

		} catch (FileNotFoundException e) {
			e.printStackTrace(System.err);
		}

	}

	private static Collection<FileScore> getSorted(Collection<FileScore> files) {

		ArrayList<FileScore> filesArray = new ArrayList<FileScore>(files);

		Collections.sort(filesArray, new Comparator<FileScore>() {

			@Override
			public int compare(FileScore o1, FileScore o2) {

				return o1.getFile().getName().compareTo(o2.getFile().getName());
			}
		});

		return filesArray;

	}
}

class FileScore {

	private File file;
	private double score;

	public FileScore(File file, double score) {
		super();
		this.file = file;
		this.score = score;
	}

	public File getFile() {
		return file;
	}

	public double getScore() {
		return score;
	}

}

class TestProcessor implements FileProcessor {

	private Collection<LinguisticCluster> clusters;

	private BinaryFileClassifier goldStandard;

	private Vocabulary vocabulary;

	private int truePositives;
	private int relevantDocuments;
	private int documentsRetrieved;

	public TestProcessor(Vocabulary vocabulary, Collection<LinguisticCluster> clusters,
			BinaryFileClassifier goldStandard) {
		super();

		this.vocabulary = vocabulary;
		this.clusters = clusters;
		this.goldStandard = goldStandard;
	}

	private LinkedList<FileScore> positiveFiles = new LinkedList<FileScore>();
	private LinkedList<FileScore> negativeFiles = new LinkedList<FileScore>();

	public LinkedList<FileScore> getPositiveFiles() {
		return positiveFiles;
	}

	public LinkedList<FileScore> getNegativeFiles() {
		return negativeFiles;
	}

	@Override
	public void processFile(File file) {
		DocumentVector document = Util.getDocumentVector(file, vocabulary);

		boolean isLinguistic = Classify.isPositive(clusters, document);

		System.out.println(ClassifierGoldStandard.canonizeName(file.getName())
				+ (isLinguistic ? "\tX" : ""));

		boolean isLinguisticGold = false;
		try {
			isLinguisticGold = goldStandard.isPositive(file);
		} catch (NotClassifiedException e) {
			e.printStackTrace(System.err);
		}

		if (isLinguisticGold) {
			relevantDocuments++;
		}

		FileScore fileScore = new FileScore(file, Classify.getPositiveSimliarityScore(clusters,
				document));

		if (isLinguistic) {
			positiveFiles.add(fileScore);

			documentsRetrieved++;

			if (isLinguisticGold) {
				truePositives++;

			}
		} else {
			negativeFiles.add(fileScore);
		}

		if (Globals.IsDebugEnabled) {
			if (isLinguistic && !isLinguisticGold) {
				System.err.println("False positive:\t" + file.getName());
			}

			else if (!isLinguistic && isLinguisticGold) {
				System.err.println("False negative :\t" + file.getName());
			}
		}

	}

	public void printPrescisionRecall(PrintStream out) {
		double precision = (double) truePositives / (double) documentsRetrieved;
		double recall = (double) truePositives / (double) relevantDocuments;

		out.println("Precision\t" + Formatters.PercentageFormatter.format(precision));
		out.println("Recall:\t\t" + Formatters.PercentageFormatter.format(recall));

		double fScore = MathUtil.getFScore(truePositives, documentsRetrieved, relevantDocuments);
		out.println("F-measure:\t" + Formatters.PercentageFormatter.format(fScore));
	}
}
